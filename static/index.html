<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="/static/styles.css">
  <link rel="icon" href="/static/icons/favicon/ELogoPSD.png" type="image/png">
  <title>Elevation Music</title>
  <script>
    let websocket;
    let isPaused = true;
    let songs = [];
    const wsProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const wsPort = 8765;
    const wsUrl = `${wsProtocol}://${window.location.hostname}:${wsPort}`;
    let reconnectTimer = null;
    let reconnectDelay = 1000;
    let lastState = {};
    let isVisible = true;
    let lastStateUpdateTime = Date.now();
    const MAX_STATE_UPDATE_SILENCE = 120000; // 120 seconds without state updates = zombie connection

    document.addEventListener('visibilitychange', () => {
      isVisible = document.visibilityState === 'visible';
      
      if (isVisible) {
        // Check if we haven't received state updates for a while
        const timeSinceLastUpdate = Date.now() - lastStateUpdateTime;
        if (timeSinceLastUpdate > MAX_STATE_UPDATE_SILENCE) {
          console.log('Connection appears stale, reconnecting...');
          connectWebSocket();
        } else {
          console.log('Tab is visible again, checking connection...');
          // Force reconnect if connection is closed or in error state
          if (!websocket || websocket.readyState !== WebSocket.OPEN) {
            connectWebSocket();
          } else {
            // Request state refresh from server even if connected
            sendCommand('get_state');
          }
        }
      }
    });

    const connectWebSocket = () => {
      if (websocket) {
        try {
          websocket.onclose = null;
          websocket.close();
        } catch (e) {
          console.error("Error closing existing websocket:", e);
        }
      }
      
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      
      console.log(`Connecting to WebSocket at ${wsUrl}`);
      
      websocket = new WebSocket(wsUrl);
      
      websocket.onopen = () => {
        console.log("Connected to WebSocket server");
        reconnectDelay = 1000;
        setStatus("Connected", 1000);
        // Get current state immediately after connection
        sendCommand('get_state');
      };
      
      websocket.onmessage = event => {
        try {
          const data = JSON.parse(event.data);
          
          if (data.songs || data.state) {
            // Update the timestamp whenever we get a real state update
            lastStateUpdateTime = Date.now();
          }
          
          // Store state first so it's available during song population
          if (data.state) {
            lastState = data.state;
          }
          
          if (data.songs) {
            songs = data.songs;
            populateSongs(songs);
            
            // Add a small delay before updating UI to ensure the DOM is ready
            // This helps with cases where songs are populated but we need to highlight active
            setTimeout(() => {
              if (lastState && Object.keys(lastState).length > 0) {
                updateUI(lastState);
              }
            }, 50);
          } else if (data.state) {
            // Only update UI for state changes if not handling songs at the same time
            updateUI(data.state);
          }
          
          if (data.message) {
            setStatus(data.message, 5000);
          }
        } catch (e) {
          console.error("Error parsing WebSocket message:", e, event.data);
        }
      };
      
      websocket.onerror = error => {
        console.error("WebSocket Error:", error);
      };
      
      websocket.onclose = () => {
        console.log(`WebSocket closed. Reconnecting in ${reconnectDelay/1000}s...`);
        
        reconnectTimer = setTimeout(() => {
          connectWebSocket();
          reconnectDelay = Math.min(reconnectDelay * 1.5, 30000);
        }, reconnectDelay);
      };
    };

    const setStatus = (message, timeout = 5000) => {
      const statusEl = document.getElementById('status');
      if (!statusEl) return;
      
      statusEl.innerText = message;
      if (timeout > 0) {
        setTimeout(() => {
            if (statusEl.innerText === message) {
                statusEl.innerText = "";
            }
        }, timeout);
      }
    };

    const sendCommand = (command) => {
      if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.send(command);
        return true;
      } else {
        setStatus("Connection error. Reconnecting...", 2000);
        connectWebSocket();
        return false;
      }
    };

    const playPauseToggle = () => sendCommand(isPaused ? "play" : "pause");
    const playSong = index => sendCommand(`play:${index}`);
    const toggleShuffle = () => sendCommand("toggle-shuffle");

    const easeInOutQuad = t => (t < 0.5 ? 2*t*t : -1 + (4-2*t)*t);
    const animateScroll = (container, target, duration) => {
      const start = container.scrollTop;
      const change = target - start;
      const startTime = performance.now();
      const animateScrollStep = currentTime => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        container.scrollTop = start + change * easeInOutQuad(progress);
        if (progress < 1) requestAnimationFrame(animateScrollStep);
      };
      requestAnimationFrame(animateScrollStep);
    };

    const updateUI = state => {
      // Only proceed if we have a valid state with current_index
      if (!state || typeof state.current_index !== 'number') {
        console.error("Invalid state object received:", state);
        return;
      }
      
      isPaused = state.paused;
      document.getElementById('playPauseIcon').src = state.paused ?
          '/static/icons/svg/filled/play.svg' : '/static/icons/svg/filled/pause.svg';
      const shuffleBtn = document.getElementById('shuffleButton');
      state.shuffle ? shuffleBtn.classList.add('active') : shuffleBtn.classList.remove('active');
      
      // Handle song highlighting and scrolling
      highlightAndScrollToActiveTrack(state.current_index);
    };

    // Separate function to handle highlighting and scrolling to active track
    const highlightAndScrollToActiveTrack = (currentIndex) => {
      const container = document.querySelector('.table-container');
      if (!container) {
        console.error("Table container not found");
        return;
      }
      
      const rows = document.querySelectorAll('#songsTable tbody tr');
      if (!rows.length) {
        console.error("No song rows found");
        return;
      }
      
      // First remove active class from all rows
      rows.forEach(row => row.classList.remove('active'));
      
      // Find the row that should be active
      const activeRow = rows[currentIndex];
      if (!activeRow) {
        console.error(`No row found at index ${currentIndex}`);
        return;
      }
      
      // Add active class to the current track
      activeRow.classList.add('active');
      
      // Calculate scroll position to center the active song
      const offset = activeRow.offsetTop - (container.clientHeight / 2) + (activeRow.clientHeight / 2);
      
      // Only scroll if the element is not already fully visible
      const rowTop = activeRow.offsetTop;
      const rowBottom = rowTop + activeRow.offsetHeight;
      const containerTop = container.scrollTop;
      const containerBottom = containerTop + container.clientHeight;
      
      if (rowTop < containerTop || rowBottom > containerBottom) {
        // Animate scrolling only if the row is outside the visible area
        animateScroll(container, offset, 500);
      }
    };

    const populateSongs = songsList => {
      const tbody = document.querySelector('#songsTable tbody');
      tbody.innerHTML = "";
      songsList.forEach((song, index) => {
        const row = tbody.insertRow();
        const cell = row.insertCell(0);
        cell.innerText = song.name;
        row.addEventListener('click', () => {
            // First send the command to play this song
            playSong(index);
            
            // Clear the search box and reset the display
            const searchBox = document.getElementById('search');
            searchBox.value = '';
            searchBox.dispatchEvent(new Event('input'));
            
            // Manually set this row as active immediately for better UX
            // Server will eventually confirm this, but this makes the UI feel more responsive
            document.querySelectorAll('#songsTable tbody tr').forEach((r, i) => {
                r.classList.toggle('active', i === index);
            });
            
            // Scroll to the clicked row
            highlightAndScrollToActiveTrack(index);
        });
      });
    };

    const handleSearch = e => {
      const query = e.target.value.toLowerCase();
      const rows = document.querySelectorAll('#songsTable tbody tr');
      let activeIndex = -1;
      let matchCount = 0;
      
      // Find the currently active row before changing display
      rows.forEach((row, index) => {
        if (row.classList.contains('active')) {
          activeIndex = index;
        }
      });
      
      // Apply search filtering
      rows.forEach(row => {
        const cellText = row.querySelector('td').innerText.toLowerCase();
        const matches = cellText.includes(query);
        row.style.display = matches ? '' : 'none';
        if (matches) {
          matchCount++;
        }
      });
      
      // Handle empty query case
      if (query === "") {
        rows.forEach(row => row.style.display = '');
        
        // If we have an active track, scroll to it
        if (activeIndex >= 0 && rows[activeIndex]) {
          setTimeout(() => {
            highlightAndScrollToActiveTrack(activeIndex);
          }, 50);
        } else {
          // If no active track, center the list
          const container = document.querySelector('.table-container');
          const newScrollTop = (container.scrollHeight - container.clientHeight) / 2;
          animateScroll(container, newScrollTop, 500);
        }
      } else if (matchCount > 0 && activeIndex >= 0) {
        // If we have an active track and it's visible after filtering, scroll to it
        const activeRow = rows[activeIndex];
        if (activeRow && activeRow.style.display !== 'none') {
          setTimeout(() => {
            highlightAndScrollToActiveTrack(activeIndex);
          }, 50);
        }
      }
    };

    const downloadYouTubeSong = () => {
      const url = document.getElementById('youtubeURL').value;
      if (!url) {
        setStatus("Please enter a YouTube URL.", 5000);
        return;
      }
      fetch('/download', {  
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url })
      })
      .then(response => response.json())
      .then(data => {
        setStatus(data.message, 5000);
        setTimeout(() => { location.reload(); }, 2000);
      })
      .catch(err => {
        console.error("Error downloading song:", err);
        setStatus("Error downloading song. Check console for details.", 5000);
      });
    };

    const deleteActiveSong = () => {
      const activeRow = document.querySelector('#songsTable tbody tr.active');
      if (!activeRow) {
        setStatus("No active song selected for deletion.", 5000);
        return;
      }
      const songName = activeRow.querySelector('td').innerText;
      const statusEl = document.getElementById('status');
      statusEl.innerHTML = `Are you sure you want to delete "<strong>${songName}</strong>"? 
                             <button id="confirmDelete">Yes</button> 
                             <button id="cancelDelete">No</button>`;
      document.getElementById('confirmDelete').addEventListener('click', () => {
          const rows = Array.from(document.querySelectorAll('#songsTable tbody tr'));
          const index = rows.indexOf(activeRow);
          sendCommand(`delete:${index}`);
          statusEl.innerText = "";
      });
      document.getElementById('cancelDelete').addEventListener('click', () => {
          setStatus("Deletion cancelled.", 5000);
      });
    };

    window.onload = () => {
      connectWebSocket();
      document.getElementById('playPauseButton').addEventListener('click', playPauseToggle);
      document.getElementById('nextButton').addEventListener('click', () => sendCommand("next"));
      document.getElementById('backButton').addEventListener('click', () => sendCommand("back"));
      document.getElementById('shuffleButton').addEventListener('click', toggleShuffle);
      document.getElementById('submitURL').addEventListener('click', e => {
        e.preventDefault();
        downloadYouTubeSong();
      });
      document.getElementById('search').addEventListener('input', handleSearch);
      document.getElementById('deleteButton').addEventListener('click', deleteActiveSong);
    };

    window.onerror = (msg, url, lineNo, columnNo, error) => {
      console.error("Global error:", { msg, url, lineNo, columnNo, error });
      setStatus("An unexpected error occurred. Check console for details.", 5000);
      return false;
    };

    window.addEventListener("unhandledrejection", event => {
      console.error("Unhandled promise rejection:", event.reason);
      setStatus("An error occurred with a background task.", 5000);
    });
  </script>
</head>
<body>
  <p id="status"></p>
  <div class="button-container">
      <button id="backButton" class="audio-control">
          <img src="/static/icons/svg/filled/back.svg" alt="Back" width="45" height="45">
      </button>
      <button id="playPauseButton" class="audio-control">
          <img id="playPauseIcon" src="/static/icons/svg/filled/play.svg" alt="Play/Pause" width="45" height="45">
      </button>
      <button id="nextButton" class="audio-control">
          <img src="/static/icons/svg/filled/next.svg" alt="Next" width="45" height="45">
      </button>
      <button id="shuffleButton">Shuffle</button>
  </div>
  <div class="youtube-container">
      <input type="url" id="youtubeURL" placeholder="Paste YouTube URL">
      <input type="submit" id="submitURL" value="Submit">
  </div>
  <div class="form-group">
      <input type="text" id="search" class="form-control" placeholder="Search for a song">
      <button id="deleteButton">Delete</button> 
  </div>
  <div class="table-container">
      <table id="songsTable">
          <thead>
              <tr>
                  <th></th>
              </tr>
          </thead>
          <tbody></tbody>
      </table>
  </div>
</body>
</html>