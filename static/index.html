<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="/static/styles.css">
  <title>Elevation Music</title>
  <script>
    let websocket;
    let isPaused = true;
    let songs = [];
    const wsProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const wsPort = 8765;
    const wsUrl = `${wsProtocol}://${window.location.hostname}:${wsPort}`;
    let reconnectTimer = null;
    let reconnectDelay = 1000;
    let lastState = {};
    let isVisible = true;
    let pingInterval = null;
    let lastPingTime = 0;
    const PING_INTERVAL_MS = 30000; // 30 seconds
    const MAX_PING_WAIT_MS = 10000; // 10 seconds to wait for pong
    let lastStateUpdateTime = Date.now();
    const MAX_STATE_UPDATE_SILENCE = 60000; // 1 minute without state updates = zombie connection

    document.addEventListener('visibilitychange', () => {
      isVisible = document.visibilityState === 'visible';
      
      if (isVisible) {
        // Check if we haven't received state updates for a while
        const timeSinceLastUpdate = Date.now() - lastStateUpdateTime;
        if (timeSinceLastUpdate > MAX_STATE_UPDATE_SILENCE) {
          console.log('Connection appears stale, reconnecting...');
          connectWebSocket();
        } else {
          console.log('Tab is visible again, checking connection...');
          // Force reconnect if connection is closed or in error state
          if (!websocket || websocket.readyState !== WebSocket.OPEN) {
            connectWebSocket();
          } else {
            // Request state refresh from server even if connected
            sendCommand('get_state');
          }
        }
      }
    });

    const startPingInterval = () => {
      if (pingInterval) clearInterval(pingInterval);
      
      pingInterval = setInterval(() => {
        if (websocket && websocket.readyState === WebSocket.OPEN) {
          lastPingTime = Date.now();
          websocket.send('ping');
          
          // Set up pong timeout - if server doesn't respond, assume disconnected
          setTimeout(() => {
            const pingElapsed = Date.now() - lastPingTime;
            if (pingElapsed >= MAX_PING_WAIT_MS) {
              console.log('Ping timeout - reconnecting...');
              connectWebSocket();
            }
          }, MAX_PING_WAIT_MS);
        }
      }, PING_INTERVAL_MS);
    };

    const stopPingInterval = () => {
      if (pingInterval) {
        clearInterval(pingInterval);
        pingInterval = null;
      }
    };

    const connectWebSocket = () => {
      // Stop any existing ping interval
      stopPingInterval();
      
      if (websocket) {
        try {
          websocket.onclose = null;
          websocket.close();
        } catch (e) {
          console.error("Error closing existing websocket:", e);
        }
      }
      
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      
      console.log(`Connecting to WebSocket at ${wsUrl}`);
      
      websocket = new WebSocket(wsUrl);
      
      websocket.onopen = () => {
        console.log("Connected to WebSocket server");
        reconnectDelay = 1000;
        setStatus("Connected", 1000);
        // Start ping interval
        startPingInterval();
        // Get current state immediately after connection
        sendCommand('get_state');
      };
      
      websocket.onmessage = event => {
        try {
          // Handle pong response
          if (event.data === 'pong') {
            lastPingTime = 0; // Reset ping timer
            return;
          }
          
          const data = JSON.parse(event.data);
          
          if (data.songs || data.state) {
            // Update the timestamp whenever we get a real state update
            lastStateUpdateTime = Date.now();
          }
          
          // Store state first so it's available during song population
          if (data.state) {
            lastState = data.state;
          }
          
          if (data.songs) {
            songs = data.songs;
            populateSongs(songs);
            
            // Always update UI after populating songs
            // This ensures the active class is applied correctly
            if (lastState && Object.keys(lastState).length > 0) {
              updateUI(lastState);
            }
          } else if (data.state) {
            // Only update UI for state changes if not handling songs at the same time
            updateUI(data.state);
          }
          
          if (data.message) {
            setStatus(data.message, 5000);
          }
        } catch (e) {
          console.error("Error parsing WebSocket message:", e, event.data);
        }
      };
      
      websocket.onerror = error => {
        console.error("WebSocket Error:", error);
        stopPingInterval();
      };
      
      websocket.onclose = () => {
        console.log(`WebSocket closed. Reconnecting in ${reconnectDelay/1000}s...`);
        stopPingInterval();
        
        reconnectTimer = setTimeout(() => {
          connectWebSocket();
          reconnectDelay = Math.min(reconnectDelay * 1.5, 30000);
        }, reconnectDelay);
      };
    };

    const setStatus = (message, timeout = 5000) => {
      const statusEl = document.getElementById('status');
      if (!statusEl) return;
      
      statusEl.innerText = message;
      if (timeout > 0) {
        setTimeout(() => {
            if (statusEl.innerText === message) {
                statusEl.innerText = "";
            }
        }, timeout);
      }
    };

    const sendCommand = (command) => {
      if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.send(command);
        return true;
      } else {
        setStatus("Connection error. Reconnecting...", 2000);
        connectWebSocket();
        return false;
      }
    };

    const playPauseToggle = () => sendCommand(isPaused ? "play" : "pause");
    const playSong = index => sendCommand(`play:${index}`);
    const toggleShuffle = () => sendCommand("toggle-shuffle");

    const easeInOutQuad = t => (t < 0.5 ? 2*t*t : -1 + (4-2*t)*t);
    const animateScroll = (container, target, duration) => {
      const start = container.scrollTop;
      const change = target - start;
      const startTime = performance.now();
      const animateScrollStep = currentTime => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        container.scrollTop = start + change * easeInOutQuad(progress);
        if (progress < 1) requestAnimationFrame(animateScrollStep);
      };
      requestAnimationFrame(animateScrollStep);
    };

    const updateUI = state => {
      isPaused = state.paused;
      document.getElementById('playPauseIcon').src = state.paused ?
          '/static/icons/svg/filled/play.svg' : '/static/icons/svg/filled/pause.svg';
      const shuffleBtn = document.getElementById('shuffleButton');
      state.shuffle ? shuffleBtn.classList.add('active') : shuffleBtn.classList.remove('active');
      
      const container = document.querySelector('.table-container');
      const rows = document.querySelectorAll('#songsTable tbody tr');
      rows.forEach((row, index) => {
        if (index === state.current_index) {
          row.classList.add('active');
          const offset = row.offsetTop - (container.clientHeight / 2) + (row.clientHeight / 2);
          animateScroll(container, offset, 500);
        } else {
          row.classList.remove('active');
        }
      });
    };

    const populateSongs = songsList => {
      const tbody = document.querySelector('#songsTable tbody');
      tbody.innerHTML = "";
      songsList.forEach((song, index) => {
        const row = tbody.insertRow();
        const cell = row.insertCell(0);
        cell.innerText = song.name;
        row.addEventListener('click', () => {
            playSong(index);
            const searchBox = document.getElementById('search');
            searchBox.value = '';
            searchBox.dispatchEvent(new Event('input'));
        });
      });
    };

    const handleSearch = e => {
      const query = e.target.value.toLowerCase();
      const rows = document.querySelectorAll('#songsTable tbody tr');
      rows.forEach(row => {
        const cellText = row.querySelector('td').innerText.toLowerCase();
        row.style.display = cellText.includes(query) ? '' : 'none';
      });
      if (query === "") {
        rows.forEach(row => row.style.display = '');
        const container = document.querySelector('.table-container');
        const newScrollTop = (container.scrollHeight - container.clientHeight) / 2;
        animateScroll(container, newScrollTop, 500);
      }
    };

    const downloadYouTubeSong = () => {
      const url = document.getElementById('youtubeURL').value;
      if (!url) {
        setStatus("Please enter a YouTube URL.", 5000);
        return;
      }
      fetch('/download', {  
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url })
      })
      .then(response => response.json())
      .then(data => {
        setStatus(data.message, 5000);
        setTimeout(() => { location.reload(); }, 2000);
      })
      .catch(err => {
        console.error("Error downloading song:", err);
        setStatus("Error downloading song. Check console for details.", 5000);
      });
    };

    const deleteActiveSong = () => {
      const activeRow = document.querySelector('#songsTable tbody tr.active');
      if (!activeRow) {
        setStatus("No active song selected for deletion.", 5000);
        return;
      }
      const songName = activeRow.querySelector('td').innerText;
      const statusEl = document.getElementById('status');
      statusEl.innerHTML = `Are you sure you want to delete "<strong>${songName}</strong>"? 
                             <button id="confirmDelete">Yes</button> 
                             <button id="cancelDelete">No</button>`;
      document.getElementById('confirmDelete').addEventListener('click', () => {
          const rows = Array.from(document.querySelectorAll('#songsTable tbody tr'));
          const index = rows.indexOf(activeRow);
          sendCommand(`delete:${index}`);
          statusEl.innerText = "";
      });
      document.getElementById('cancelDelete').addEventListener('click', () => {
          setStatus("Deletion cancelled.", 5000);
      });
    };

    window.onload = () => {
      connectWebSocket();
      document.getElementById('playPauseButton').addEventListener('click', playPauseToggle);
      document.getElementById('nextButton').addEventListener('click', () => sendCommand("next"));
      document.getElementById('backButton').addEventListener('click', () => sendCommand("back"));
      document.getElementById('shuffleButton').addEventListener('click', toggleShuffle);
      document.getElementById('submitURL').addEventListener('click', e => {
        e.preventDefault();
        downloadYouTubeSong();
      });
      document.getElementById('search').addEventListener('input', handleSearch);
      document.getElementById('deleteButton').addEventListener('click', deleteActiveSong);
    };

    window.onerror = (msg, url, lineNo, columnNo, error) => {
      console.error("Global error:", { msg, url, lineNo, columnNo, error });
      setStatus("An unexpected error occurred. Check console for details.", 5000);
      return false;
    };

    window.addEventListener("unhandledrejection", event => {
      console.error("Unhandled promise rejection:", event.reason);
      setStatus("An error occurred with a background task.", 5000);
    });
  </script>
</head>
<body>
  <p id="status"></p>
  <div class="button-container">
      <button id="backButton" class="audio-control">
          <img src="/static/icons/svg/filled/back.svg" alt="Back" width="45" height="45">
      </button>
      <button id="playPauseButton" class="audio-control">
          <img id="playPauseIcon" src="/static/icons/svg/filled/play.svg" alt="Play/Pause" width="45" height="45">
      </button>
      <button id="nextButton" class="audio-control">
          <img src="/static/icons/svg/filled/next.svg" alt="Next" width="45" height="45">
      </button>
      <button id="shuffleButton">Shuffle</button>
  </div>
  <div class="youtube-container">
      <input type="url" id="youtubeURL" placeholder="Paste YouTube URL">
      <input type="submit" id="submitURL" value="Submit">
  </div>
  <div class="form-group">
      <input type="text" id="search" class="form-control" placeholder="Search for a song">
      <button id="deleteButton">Delete</button> 
  </div>
  <div class="table-container">
      <table id="songsTable">
          <thead>
              <tr>
                  <th></th>
              </tr>
          </thead>
          <tbody></tbody>
      </table>
  </div>
</body>
</html>